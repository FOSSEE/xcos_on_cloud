<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
        <meta content="utf-8" http-equiv="encoding"/>
        <title>
            Xcos
        </title>
        <!-- Loads and initializes the library -->
        <script src="jquery/jquery-1.8.2.js" type="text/javascript"></script>
        <script src="mxClient.min.js" type="text/javascript"></script>
        <script src="jquery/farbtastic.js" type="text/javascript"></script>
        <link href="jquery/farbtastic.css" rel="stylesheet" type="text/css"/>
        <link href="jquery/jquery-ui.css" rel="stylesheet"/>
        <script src="math.js" type="text/javascript"></script>
        <script src="complex.min.js" type="text/javascript"></script>
        <script src="indexfunctions.js" type="text/javascript"></script>
        <script src="dependencies.js" type="text/javascript"></script>
        <script src="details.js" type="text/javascript"></script>
        <script src="setup.js" type="text/javascript"></script>
        <script src="combined.js" type="text/javascript"></script>
        <script src="orientation.js" type="text/javascript"></script>
        <script src="only_scifunc_code.js" type="text/javascript"></script>
        <script src="importparameters.js" type="text/javascript"></script>
        <script src="LOOKUP_CURV.js" type="text/javascript"></script>
        <script type="text/javascript" src="highcharts/highcharts.js"></script> <!-- Used for producing 2d-highcharts -->
        <script type="text/javascript" src="highcharts/highcharts-3d.js"></script> <!-- Used for producing 3d-highcharts in output if required --> 
        <script type="text/javascript" src="highcharts/exporting.js"></script> <!-- Used for the exporting feature of highcharts -->
        <script type="text/javascript" src="highcharts/draggable-points.js"></script><!-- Used for dragging graph points -->


        <script src="Queue.js" type="text/javascript"></script>
        <script src="chart.js" type="text/javascript"></script>
        <script type="text/javascript">

        var example_content = "{{ example_content }}";
        var filename = "{{ filename }}";
         var editor ;
         var listofAffichCell = [];
         var winArr = new Array();

         /*
            referenceModelProp is an array of objects used for saving ids and names of all nodes present in the xml (once properties window is opened) so that
            when set function is called this array can be used for comparison for setting up link nodes and connecting wires
         */
         var referenceModelProps = [];
         var modelNextId;             // Stores ID of next Key    

         window.onbeforeunload = function (e) {
             
                    		return "Please click 'Stay on this Page' if you did this unintentionally";
                	};
              // Stores edgeState for every recently created edge in updateFixedTerminalPoint() function  
                var edgeState = {};
         var xmlCode;  			// we store the xml code obtained after pressing simulate button
         var valueArr = new Array();	// stores the updated values of each tk block
         var tkclk = new Array();	// stores the clock (Period) parameter value of individual tkscale 
         
         for(var i=0;i<10;i++)    	// initialising to zero
         	tkclk[i]=0;
         
         //  function which makes the Ajax 'post' request with data sent in arguments   
         function myAjaxreq(k,functionName)
         {
         	var mbl = new Blob([k], { type: 'text/plain' });  // store the data in blob				
         	var formd = new FormData();   
                        formd.append("file",mbl); // using formdata
           
                        var xhrq = new XMLHttpRequest(); 
                        xhrq.open("POST",functionName, true);
                        xhrq.onload = function()
         	{
                                
                            if(this.responseText!='error')
         	    {
                                   var response = this.responseText; // response can be used further if needed
         		   
                            }
         	    else
         	    {
                                  alert("Error");
                            }
                        };
                      
                        xhrq.send(formd); // data to be requested	
         
         } 
         
        function httpGetAsync(theUrl, callback)
        {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.onreadystatechange = function() {
                if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                    callback(xmlHttp.responseText);
            }
            xmlHttp.open("GET", theUrl, true); // true for asynchronous
            xmlHttp.send(null);
        }

        function StopTK() // function which deletes the sliders and related files which are created
        {
            if (winArr.length > 0) {
                myAjaxreq("Stop", "/UpdateTKfile?id="+clientID);
                for (var i = 0; i < winArr.length; i++)
                    winArr[i].close();
                winArr = new Array();
            }
        }

         var importxcos; // variable used at anonymous function in importXcos event   
         var xeditor,xcell;
         
         function GetcurVal()  // function which updates the slider values and send ajax req with the updated data    
         {
         		
         		valueArr[0]=tkclk[0]+tk1.innerHTML;			
         		valueArr[1]=tkclk[1]+tk2.innerHTML;
         		valueArr[2]=tkclk[2]+tk3.innerHTML;
         		valueArr[3]=tkclk[3]+tk4.innerHTML;
         		valueArr[4]=tkclk[4]+tk5.innerHTML;
         		valueArr[5]=tkclk[5]+tk6.innerHTML;
         		valueArr[6]=tkclk[6]+tk7.innerHTML;
         		valueArr[7]=tkclk[7]+tk8.innerHTML;
         		valueArr[8]=tkclk[8]+tk9.innerHTML;
         		valueArr[9]=tkclk[9]+tk10.innerHTML;
         
                        myAjaxreq(valueArr, "/UpdateTKfile?id="+clientID); // send the request
         
         }
         
                /*
                  @jiteshjha
                  Creates a dialog box related to the edge label properties.
                  The properties implemented are : edge label, label fontStyle,
                  label fontSize, label fontStyle.
                */
         
         
                function showTextEditWindow(graph, cell) {
                    var fontFamilyList = {
                        "Arial": 0,
                        "Dialog": 1,
                        "Verdana": 2,
                        "Times New Roman": 3
                    }
                    var defaultProperties = {
                        text: ["Text", "text"],
                        fontFamily: ["Font Family", fontFamilyList],
                        fontSize: ["fontSize", 20]
                    };
         
                    var style = graph.getModel().getStyle(cell);
                    var styleObject = styleToObject(style);
                    if ('fontSize' in styleObject) {
                        defaultProperties['fontSize'][1] = styleObject['fontSize'];
                    }
                    if (cell.value != "") {
                        defaultProperties['text'][1] = cell.value;
                    }
         
                    // Create basic structure for the form
                    var content = document.createElement('div');
                    content.setAttribute("id", "contentProperties");
         
                    // Heading of content
                    var heading = document.createElement('h2');
                    heading.innerHTML = "Text and Text Font";
                    heading.id = "headingProperties"
                    content.appendChild(heading);
         
                    // Add Form
                    var myform = document.createElement("form");
                    myform.method = "post";
                    myform.id = "formProperties";
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    for (var key in defaultProperties) {
                        if (defaultProperties.hasOwnProperty(key)) {
         
                            // Input Title
                            var fieldName = defaultProperties[key];
                            var namelabel = document.createElement('label');
                            namelabel.innerHTML = defaultProperties[key][0];
                            myform.appendChild(namelabel);
         
                            if (key == "fontFamily") {
                                //Here we create a "select" element (a drop down list).
                                var newList = document.createElement("select");
                                newList.style.cssText = "float:right";
                                newList.setAttribute("id", key.toString());
                                var dropdownItems = defaultProperties[key][1];
         
                                for (var item in dropdownItems) {
                                    if (dropdownItems.hasOwnProperty(item)) {
                                        option = document.createElement('option');
                                        option.value = item;
                                        option.text = item;
                                        option.setAttribute("id", item);
                                        newList.appendChild(option);
                                    }
                                }
         
                                var selectedFontFamily = 0;
                                var styleObject = styleToObject(style);
                                if ('fontFamily' in styleObject) {
                                    selectedFontFamily = styleObject['fontFamily'];
                                }
                                newList.selectedIndex = dropdownItems[selectedFontFamily];
                                myform.appendChild(newList);
                            } else {
                                var input = document.createElement("input");
                                input.name = key;
                                input.value = defaultProperties[key][1];
                                input.setAttribute("id", key.toString());
                                input.setAttribute("class", "fieldInput");
                                myform.appendChild(input);
                            }
                            // Line break
                            var linebreak = document.createElement('br');
                            myform.appendChild(linebreak);
         
                            // Line break
                            var linebreak = document.createElement('br');
                            myform.appendChild(linebreak);
                        }
                    }
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    /*
                      changeFontStyle function sets the style for given fontStyle and toggles with the active class
                      for "set" type, and toggles with the active class for "get" type.
                    */
                    function changeFontStyle(type, graph, cell, button, bit) {
                        var style = graph.getModel().getStyle(cell);
                        var trigger = document.getElementById(button);
                        var styleObject = styleToObject(style);
                        var previousValue = 1;
                        if ('fontStyle' in styleObject) {
                            previousValue = styleObject['fontStyle'];
         
                            // To get a bit mask:
                            var mask = 1 << bit; // Get the 1st element
         
                            if (type == "get") {
                                // toggle the bit
                                previousValue ^= mask;
                                trigger.classList.toggle(button);
                                styleObject['fontStyle'] = previousValue;
                                style = objectToStyle(styleObject);
                                graph.getModel().setStyle(cell, style);
                            } else if (type == "set") {
                                if ((previousValue & mask) != 0) {
                                    trigger.classList.toggle(button);
                                }
                            }
                        }
                    }
         
                    // Button - Bold
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Bold';
                    btn.setAttribute("id", "boldButton");
                    btn.type = "button";
                    btn.name = "submit";
                    btn.onclick = function() {
                        changeFontStyle("get", graph, cell, 'boldButton', 0);
                    }
                    myform.appendChild(btn);
         
                    // Button - Italics
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Italic';
                    btn.setAttribute("id", "italicButton");
                    btn.type = "button";
                    btn.name = "submit";
                    btn.onclick = function() {
                        changeFontStyle("get", graph, cell, 'italicButton', 1);
                    }
                    myform.appendChild(btn);
         
                    // Button - Underline
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Underline';
                    btn.setAttribute("id", "underlineButton");
                    btn.type = "button";
                    btn.name = "submit";
                    btn.onclick = function() {
                        changeFontStyle("get", graph, cell, 'underlineButton', 2);
                    }
                    myform.appendChild(btn);
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    // Button - Submit
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Submit';
                    btn.type = "button";
                    btn.name = "submit";
         
                    // Executes when button 'btn' is clicked
                    btn.onclick = function() {
                        var propertiesObject = {
                            id: cell.id
                        };
                        for (var key in defaultProperties) {
                            if (defaultProperties.hasOwnProperty(key)) {
                                propertiesObject[key] = document.getElementById(key.toString()).value;
                            }
                        }
                        var style = graph.getModel().getStyle(cell);
                        var styleObject = styleToObject(style);
                        styleObject['fontSize'] = propertiesObject['fontSize'];
                        styleObject['fontFamily'] = propertiesObject['fontFamily'];
                        style = objectToStyle(styleObject);
                        graph.getModel().setStyle(cell, style);
                        graph.getModel().setValue(cell, propertiesObject['text']);
                        wind.destroy();
                    };
                    myform.appendChild(btn);
         
                    // Base heights without fields : 135 px
                    height = 135 + 26 * defaultProperties.length + 15;
                    content.appendChild(myform);
                    var wind = showModalWindow(graph, 'Text and Text font', content, 450, height);
         
                    /*
                      @jiteshjha
                      If any fontStyle(Bold, Italic, Underline) has already been implemented
                      for the selected edge label, add the respective active class to that button.
                    */
         
                    if ('fontStyle' in styleObject) {
                        changeFontStyle("set", graph, cell, 'boldButton', 0);
                        changeFontStyle("set", graph, cell, 'italicButton', 1);
                        changeFontStyle("set", graph, cell, 'underlineButton', 2);
                    }
                };
                /*
                  @jiteshjha, @pooja
                  showSetupWindow dialog box
                */
         
                /*
                    Maverick
                    Added 'diagRoot' parameter.
                */
                function showSetupWindow(graph, diagRoot) {
         
                    /*
                        Maverick
                        Added one more element in the list for each key to be used in the <XcosDiagram>
                        tag.
                    */
         
                    var defaultProperties = setup("get");
         
                    // Create basic structure for the form
                    var content = document.createElement('div');
                    content.setAttribute("id", "contentProperties");
         
                    // Heading of content
                    var heading = document.createElement('h2');
                    heading.innerHTML = "Setup";
                    heading.id = "headingProperties"
                    content.appendChild(heading);
         
                    // Add Form
                    var myform = document.createElement("form");
                    myform.method = "post";
                    myform.id = "formProperties";
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    for (var key in defaultProperties) {
                        if (defaultProperties.hasOwnProperty(key)) {
         
                            // Input Title
                            var fieldName = defaultProperties[key];
                            var namelabel = document.createElement('label');
                            namelabel.innerHTML = defaultProperties[key][0];
                            myform.appendChild(namelabel);
         
                            if (key == "solv_kind") {
         
                                //Here we create a "select" element (a drop down list).
                                var newList = document.createElement("select");
                                newList.style.cssText = "float:right";
                                newList.setAttribute("id", key.toString());
                                var dropdownItems = setup("getArray");
         
                                // Iterate over the dropdown options and create html elements
                                dropdownItems.forEach(function(value, i) {
                                    option = document.createElement('option');
                                    option.value = i.toFixed(1);
                                    option.text = value;
                                    newList.appendChild(option);
                                });
                                newList.selectedIndex = defaultProperties[key][2];
                                myform.appendChild(newList);
         
                            } else {
                                var input = document.createElement("input");
                                input.name = key;
                                input.value = defaultProperties[key][2];
                                input.setAttribute("id", key.toString());
                                input.setAttribute("class", "fieldInput");
                                myform.appendChild(input);
                            }
         
                            // Line break
                            var linebreak = document.createElement('br');
                            myform.appendChild(linebreak);
         
                            // Line break
                            var linebreak = document.createElement('br');
                            myform.appendChild(linebreak);
                        }
                    }
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    // Button - Set Context
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Set Context';
                    btn.style.cssText = 'float: left';
                    btn.type = "button";
                    btn.name = "submit";
                    btn.id = "resetButtonProperties";
                    btn.onclick = function() {
                        // show Set Context
                        /*
                            Maverick
                            Added the parameter here as well.
                        */
                        showSetContext(graph, diagRoot);
                    };
                    myform.appendChild(btn);
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
         
                    // Button - Submit
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Submit';
                    btn.type = "button";
                    btn.name = "submit";
         
                    // Executes when button 'btn' is clicked
                    btn.onclick = function() {
                        var propertiesObject = {};
         
                        for (var key in defaultProperties) {
                            if (defaultProperties.hasOwnProperty(key)) {
                                propertiesObject[defaultProperties[key][1]] = document.getElementById(key.toString()).value;
         
                                /*
                                    Maverick
                                    Adding the corresponding attributes to the <XcosDiagram> tag.
                                */
                                diagRoot[defaultProperties[key][1]] = document.getElementById(key.toString()).value;
                            }
                        }
         
                        setup("set", propertiesObject);
                        wind.destroy();
                    };
         
                    myform.appendChild(btn);
         
         
                    // Button - Reset
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Reset';
                    btn.type = "button";
                    btn.name = "submit";
                    btn.id = "resetButtonProperties";
                    btn.onclick = function() {
                        // Reset
                        for (var key in defaultProperties) {
                            if (defaultProperties.hasOwnProperty(key)) {
                                var element = document.getElementById(key.toString());
                                if (key != "solv_kind") {
                                    element.value = defaultProperties[key][2];
                                } else {
                                    /*
                                        Maverick
                                        Code modified to reset the drop down list.
                                    */
                                    element.selectedIndex = 0;
                                }
                            }
                        }
                    };
         
                    myform.appendChild(btn);
                    // Base height without fields : 135 px
                    height = 135 + 26 * defaultProperties.length + 15;
         
                    content.appendChild(myform);
                    var wind = showModalWindow(graph, 'Set Parameters', content, 450, height);
                };
         
                function showColorWheel(graph, cell, selectProperty) {
                    // Create basic structure for the form
                    var content = document.createElement('div');
                    content.setAttribute("id", "colorProperties");
                    // Add Form
                    var myform = document.createElement("form");
                    myform.method = "";
                    myform.setAttribute("id", "formProperties");
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
                    // Input Title
                    var fieldName = 'Color';
                    var namelabel = document.createElement('label');
                    namelabel.innerHTML = fieldName;
                    myform.appendChild(namelabel);
                    // Input
                    var input = document.createElement("input");
                    input.name = fieldName;
                    input.value = 0;
                    input.style.cssText = 'float: right;';
                    input.setAttribute("id", "color");
                    myform.appendChild(input);
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
                    var picker = document.createElement('div');
                    picker.setAttribute("id", "picker");
                    myform.appendChild(picker);
                    // Line break
                    var linebreak = document.createElement('br');
                    myform.appendChild(linebreak);
                    // Button - Submit
                    var btn = document.createElement("button");
                    btn.innerHTML = 'Submit';
                    btn.type = "button";
                    btn.name = "submit";
                    btn.style.cssText = 'margin-left: 75px';
                    // Executes when button 'btn' is clicked
                    btn.onclick = function() {
                        var selectedCells = graph.getSelectionCells();
                        graph.getModel().beginUpdate();
                        try {
                            for (var count = 0; count < selectedCells.length; count++) {
                                var selectedCell = selectedCells[count];
                                var input = document.getElementById('color').value;
                                var style = graph.getModel().getStyle(selectedCell);
         
                                if (style != null) {
                                    var styleObject = styleToObject(style);
                                }
         
                                if (selectProperty == "edgeStrokeColor") {
                                    styleObject['strokeColor'] = input;
                                } else if (selectProperty == "bgColor") {
                                    graph.container.style.backgroundColor = input;
                                } else if (selectProperty == "vertexStrokeColor") {
                                    styleObject['strokeColor'] = input;
                                } else if (selectProperty == "vertexFillColor") {
                                    styleObject['fillColor'] = input;
                                } else if (selectProperty == "edgeTextColor") {
                                    styleObject['fontColor'] = input;
                                }
         
                                if (style != null) {
                                    style = objectToStyle(styleObject);
                                    graph.getModel().setStyle(selectedCell, style);
                                }
                            }
                        } finally {
                            graph.getModel().endUpdate();
                        }
         
                        wind.destroy();
                    };
                    myform.appendChild(btn);
                    content.appendChild(myform);
                    var wind = showModalWindow(graph, 'Diagram background...', content, 285, 340);
                    // Invokes the farbtastic functionality
                    $(document).ready(function() {
                        $('#picker').farbtastic('#color');
                    });
                };
         
                function createButtonImage(button, image) {
                    if (image != null) {
                        var img = document.createElement('img');
                        img.setAttribute('src', image);
                        img.style.width = '16px';
                        img.style.height = '16px';
                        img.style.verticalAlign = 'middle';
                        img.style.marginRight = '2px';
                        button.appendChild(img);
                    }
                }
         
                function addIcons(graph, sidebar) {
                    var req = mxUtils.load('palettes/palettes.xml');
                    var root = req.getDocumentElement();
                    var x = root.getElementsByTagName('node')[0];
                    var categories = x.getElementsByTagName('node');
                    for (var i = 0, nodeLength = categories.length; i < nodeLength; i++) {
                        var categoryName = categories[i].getAttribute('name');
                        var title = document.createElement('h3');
                        title.setAttribute('class', 'accordion-header ui-accordion-header ui-helper-reset ui-state-default ui-accordion-icons ui-corner-all');
                        var span = document.createElement('span');
                        span.setAttribute('class', 'ui-accordion-header-icon ui-icon ui-icon-triangle-1-e');
                        var titleName = document.createTextNode(categoryName);
                        title.appendChild(span);
                        title.appendChild(titleName);
                        sidebar.appendChild(title);
                        var newImages = document.createElement('div');
                        newImages.setAttribute('class', 'ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom');
                        var blocks = categories[i].getElementsByTagName('block');
                        for (var j = 0, blockLength = blocks.length; j < blockLength; j++) {
                            var name = blocks[j].getAttribute('name');
                            var icon = blocks[j].getElementsByTagName('icon')[0];
                            var iconPath = icon.getAttribute('path');
                            addSidebarIcon(graph, newImages, name, iconPath);
                        }
                        sidebar.appendChild(newImages);
                    }
                }
         
                function addToolbarButton(editor, toolbar, action, label, image, isTransparent) {
                    var button = document.createElement('button');
                    button.style.fontSize = '10';
                    button.style.borderWidth = '2px';
                    button.style.padding = '1px 6px 1px 6px';
                    createButtonImage(button, image);
                    if (isTransparent) {
                        button.style.background = 'transparent';
                        button.style.color = '#FFFFFF';
                        button.style.border = 'none';
                    }
                    mxEvent.addListener(button, 'click', function(evt) {
                        editor.execute(action);
                    });
                    mxUtils.write(button, label);
                    button.setAttribute('id', action);
                    toolbar.appendChild(button);
                };
         
                function showModalWindow(graph, title, content, width, height) {
                    var background = document.createElement('div');
                    background.style.position = 'absolute';
                    background.style.left = '0px';
                    background.style.top = '0px';
                    background.style.right = '0px';
                    background.style.bottom = '0px';
                    background.style.background = 'black';
                    mxUtils.setOpacity(background, 50);
                    document.body.appendChild(background);
         
                    if (mxClient.IS_IE) {
                        new mxDivResizer(background);
                    }
         
                    var x = Math.max(0, document.body.scrollWidth / 2 - width / 2);
                    var y = Math.max(10, (document.body.scrollHeight || document.documentElement.scrollHeight) / 2 - height * 2 / 3);
                    var wind = new mxWindow(title, content, x, y, width, height, false, true);
                    wind.setClosable(true);
         
                    // Fades the background out after after the window has been closed
                    wind.addListener(mxEvent.DESTROY, function(evt) {
                        graph.setEnabled(true);
                        mxEffects.fadeOut(background, 50, true, 10, 30, true);
                    });
         
                    graph.setEnabled(false);
                    graph.tooltipHandler.hide();
                    wind.setVisible(true);
                    return wind;
                };
         
                var flag = 0;
         
                function addSidebarIcon(graph, sidebar, name, image) {
                    // Function that is executed when the image is dropped on
                    // the graph. The cell argument points to the cell under
                    // the mousepointer if there is one.
                    var funct = function(graph, evt, cell, x, y) {
                        var parent = graph.getDefaultParent();
                        var model = graph.getModel();
                        var v1 = null;
                        var doc = mxUtils.createXmlDocument();
                        model.beginUpdate();
                        try {
                            var details_instance = new window[name]();
                            var details = details_instance.define();
                            var enc = new mxCodec(mxUtils.createXmlDocument());
                            var node = enc.encode(details);
                            var temp = enc.encode(parent);
         
                            // Get the stylesheet for the graph
                            var stylesheet = graph.getStylesheet();
                            // From the stylesheet, get the style of the particular block
                            var style = stylesheet.styles[name];
         
                            /*
                             * When a particular block is loaded for the first time,
                             * the image in the style of the block will be a path to the image.
                             * Set the label in the style property of the block has a html image,
                             * and set the image in the style property as null
                             *
                             * NOTE: Since the image of any block need not be changed for
                             *       for every movement of that block, the image must be
                             *       set only once.
                             */
                            if (style != null && style['image'] != null) {
         
                                // Make label as a image html element
                                var label = '<img src="' + style['image'] + '" height="80" width="80">';
         
                                // Set label
                                style['label'] = label;
         
                                style['imagePath'] = style['image'];
         
                                // Set image as null
                                style['image'] = null;
         
                                // Add the label as a part of node
                                node.setAttribute('label', label);
                            }
         
                            /*
                             * If a particular block with image tag in it's style property
                             * has been invoked already, the image tag would be null for any
                             * successive instances of the same block. Hence, set the label
                             * from the label tag in style which was set when that blockModel
                             * was invoked on the first time.
                             */
                            if (style != null && style['label'] != null) {
         
                                // Set label from the label field in the style property
                                node.setAttribute('label', style['label']);
                            }
         
                            node.setAttribute('parent', temp.getAttribute('id'));
                            var i, arr = [];
                            var blockModel = details_instance.x.model;
                            var graphics = details_instance.x.graphics;
         
                            /* To determine number and type of Port*/
                            var inputPorts = [],
                                outputPorts = [],
                                controlPorts = [],
                                commandPorts = [];
                            if (blockModel.in.height != null) {
                                arr = getData(graphics.in_implicit);
                                if (arr.length != 0) {
                                    inputPorts = arr;
                                } else {
                                    for (i = 0; i < blockModel.in.height; i++) {
                                        inputPorts.push("E");
                                    }
                                }
                            }
                            if (blockModel.out.height != null) {
                                arr = getData(graphics.out_implicit);
                                if (arr.length != 0) {
                                    outputPorts = arr;
                                } else {
                                    for (i = 0; i < blockModel.out.height; i++) {
                                        outputPorts.push("E");
                                    }
                                }
                            }
                            if (blockModel.evtin.height != null) {
                                for (i = 0; i < blockModel.evtin.height; i++) {
                                    controlPorts.push("CONTROL");
                                }
                            }
                            if (blockModel.evtout.height != null) {
                                for (i = 0; i < blockModel.evtout.height; i++) {
                                    commandPorts.push("COMMAND");
                                }
                            }
                            v1 = graph.insertVertex(parent, null, node, x, y, 80, 80, name);
         
                            // @Chhavi: Additional attribute to store the block's instance
                            v1.blockInstance = createInstanceTag(details_instance);
                            v1.currentAngle = 0;
                            v1.flipX = 1;
                            v1.flipY = 1;
                            createPorts(graph, v1, inputPorts, controlPorts, outputPorts, commandPorts);
                            v1.setConnectable(false);
                        } finally {
                            model.endUpdate();
                        }
                        graph.setSelectionCell(v1);
                    }
         
                    var para = document.createElement('p');
                    var blockFigure = document.createElement('figure');
                    var img = document.createElement('img');
                    img.setAttribute('src', image);
                    var caption = document.createElement('figcaption');
                    var blockName = document.createTextNode(name);
                    caption.appendChild(blockName);
                    blockFigure.appendChild(img);
                    blockFigure.appendChild(caption);
                    para.appendChild(blockFigure);
                    sidebar.appendChild(para);
         
                    var dragElt = document.createElement('div');
                    dragElt.style.border = 'dashed black 1px';
                    dragElt.style.width = '80px';
                    dragElt.style.height = '80px';
         
                    // Creates the image which is used as the drag icon (preview)
                    var ds = mxUtils.makeDraggable(img, graph, funct, dragElt, 0, 0, true, true);
                    ds.setGuidesEnabled(true);
                };
         
                // Create ports
                /*
                    Maverick
                    Modified the createPorts funtion so that it can be used while creating ports from 
                    a given Xcos diagram. 
                    New parameters are the parentObj where the port is supposed to be added and a dictionary
                    object which contains the mapping between the newly assigned Ids and imported Ids.
                */
                function createPorts(graph, block, left, top, right, bottom, parentObj, nodeDataObject) {
         
                    createInputPorts(graph, block, left, top, parentObj, nodeDataObject);
                    createOutputPorts(graph, block, right, bottom, parentObj, nodeDataObject);
         
                }
         
                function createInputPorts(graph, block, leftArray, topArray, parentObj, nodeDataObject) {
         
                    var topNumber = topArray.length;
                    var leftNumber = leftArray.length;
         
                    if (leftNumber != 0) {
                        for (var i = 1; i <= leftNumber; i++) {
         
                            var x = 0;
                            var y = (i / (leftNumber + 1)).toFixed(4);
                            var portType = leftArray[i - 1];
                            if (parentObj != null) {
                                createInputPort(graph, block, x, y, portType, 'left', i, nodeDataObject, parentObj.inputIds);
                            } else {
                                createInputPort(graph, block, x, y, portType, 'left', i);
                            }
         
                        }
                    }
                    if (topNumber != 0) {
                        for (var i = 1; i <= topNumber; i++) {
                            var x = (i / (topNumber + 1)).toFixed(4);
                            var y = 0;
                            var portType = topArray[i - 1];
                            if (parentObj != null) {
                                createInputPort(graph, block, x, y, portType, 'top', i, nodeDataObject, parentObj.controlIds);
                            } else {
                                createInputPort(graph, block, x, y, portType, 'top', i);
                            }
                        }
                    }
         
                };
         
                function createOutputPorts(graph, block, rightArray, bottomArray, parentObj, nodeDataObject) {
         
                    var bottomNumber = bottomArray.length;
                    var rightNumber = rightArray.length;
                    if (rightNumber != 0) {
                        for (var i = 1; i <= rightNumber; i++) {
                            var x = 1;
                            var y = (i / (rightNumber + 1)).toFixed(4);
                            var portType = rightArray[i - 1];
                            if (parentObj != null) {
                                createOutputPort(graph, block, x, y, portType, 'right', i, nodeDataObject, parentObj.outputIds);
                            } else {
                                createOutputPort(graph, block, x, y, portType, 'right', i);
                            }
                        }
                    }
                    if (bottomNumber != 0) {
                        for (var i = 1; i <= bottomNumber; i++) {
                            var x = (i / (bottomNumber + 1)).toFixed(4);
                            var y = 1;
                            var portType = bottomArray[i - 1];
                            if (parentObj != null) {
                                createOutputPort(graph, block, x, y, portType, 'bottom', i, nodeDataObject, parentObj.commandIds);
                            } else {
                                createOutputPort(graph, block, x, y, portType, 'bottom', i);
                            }
                        }
                    }
         
                };
         
                function createInputPort(graph, block, x, y, portType, position, ordering, nodeDataObject, idArray) {
         
                    var port = null;
                    if (portType == 'COMMAND') {
                        port = graph.insertVertex(block, null, 'CommandPort', x, y, 10, 10, 'CommandPort', true);
                    } else if (portType == 'CONTROL') {
                        port = graph.insertVertex(block, null, 'ControlPort', x, y, 10, 10, 'ControlPort', true);
                    } else if (portType == 'I') {
                        port = graph.insertVertex(block, null, 'ImplicitInputPort', x, y, 10, 10, 'ImplicitInputPort', true);
                    } else if (portType == 'E') {
                        port = graph.insertVertex(block, null, 'ExplicitInputPort', x, y, 10, 10, 'ExplicitInputPort', true);
                    }
                    if (port != null) {
                        if (position == 'top') {
                            port.geometry.offset = new mxPoint(-6, -10);
                        } else if (position == 'left') {
                            port.geometry.offset = new mxPoint(-10, -6);
                        }
                        port.ordering = ordering;
         
                        if (nodeDataObject != null) {
                            var obj = new Object();
                            obj.newId = port.id;
                            obj.oldId = idArray[ordering - 1];
                            nodeDataObject[idArray[ordering - 1]] = obj;
                        }
         
                        if (block.style == 'Split') {
                            port.setVisible(false);
                            port.setConnectable(false);
                        }
                    }
                };
         
                function createOutputPort(graph, block, x, y, portType, position, ordering, nodeDataObject, idArray) {
                    var port = null;
         
                    if (portType == 'COMMAND') {
                        port = graph.insertVertex(block, null, 'CommandPort', x, y, 10, 10, 'CommandPort', true);
                    } else if (portType == 'CONTROL') {
                        port = graph.insertVertex(block, null, 'ControlPort', x, y, 10, 10, 'ControlPort', true);
                    } else if (portType == 'I') {
                        port = graph.insertVertex(block, null, 'ImplicitOutputPort', x, y, 10, 10, 'ImplicitOutputPort', true);
                    } else if (portType == 'E') {
                        port = graph.insertVertex(block, null, 'ExplicitOutputPort', x, y, 10, 10, 'ExplicitOutputPort', true);
                    }
                    if (port != null) {
                        if (position == 'bottom') {
                            port.geometry.offset = new mxPoint(-6, 0);
                        }
                        if (position == 'right') {
                            port.geometry.offset = new mxPoint(0, -6);
                        }
                        port.ordering = ordering;
         
                        if (nodeDataObject != null) {
                            var obj = new Object();
                            obj.newId = port.id;
                            obj.oldId = idArray[ordering - 1];
                            nodeDataObject[idArray[ordering - 1]] = obj;
                        }
         
                        if (block.style == 'Split') {
                            port.setVisible(false);
                            port.setConnectable(false);
                        }
                    }
                };
         
                function configureStylesheet(graph) {
                    var req = mxUtils.load('styles/Xcos-style.xml');
                    var root = req.getDocumentElement();
                    var dec = new mxCodec(root.ownerDocument);
                    dec.decode(root, graph.stylesheet);
                };
             
      </script>
      <!--
         Updates connection points before the routing is called.
         -->
      <script type="text/javascript">
         // Computes the position of edge to edge connection points.
           mxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint) {
         
               // Store the edge state for every newly created edge in edgeState variable
               edgeState = edge;
               var pt = null;
         
               if (constraint != null) {
                   pt = this.graph.getConnectionPoint(terminal, constraint);
               }
         
               if (source) {
                   edge.sourceSegment = null;
               } else {
                   edge.targetSegment = null;
               }
         
               if (pt == null) {
                   var s = this.scale;
                   var tr = this.translate;
                   var orig = edge.origin;
                   var geo = this.graph.getCellGeometry(edge.cell);
                   pt = geo.getTerminalPoint(source);
         
                   // Computes edge-to-edge connection point
                   if (pt != null) {
                       pt = new mxPoint(s * (tr.x + pt.x + orig.x),
                           s * (tr.y + pt.y + orig.y));
         
                       // Finds nearest segment on edge and computes intersection
                       if (terminal != null && terminal.absolutePoints != null) {
                           var seg = mxUtils.findNearestSegment(terminal, pt.x, pt.y);
         
                           // Finds orientation of the segment
                           var p0 = terminal.absolutePoints[seg];
                           var pe = terminal.absolutePoints[seg + 1];
                           var horizontal = (p0.x - pe.x == 0);
         
                           // Stores the segment in the edge state
                           var key = (source) ? 'sourceConstraint' : 'targetConstraint';
                           var value = (horizontal) ? 'horizontal' : 'vertical';
                           edge.style[key] = value;
         
                           // Keeps the coordinate within the segment bounds
                           if (horizontal) {
                               pt.x = p0.x;
                               pt.y = Math.min(pt.y, Math.max(p0.y, pe.y));
                               pt.y = Math.max(pt.y, Math.min(p0.y, pe.y));
                           } else {
                               pt.y = p0.y;
                               pt.x = Math.min(pt.x, Math.max(p0.x, pe.x));
                               pt.x = Math.max(pt.x, Math.min(p0.x, pe.x));
                           }
                       }
                   }
                   // Computes constraint connection points on vertices and ports
                   else if (terminal != null && terminal.cell.geometry.relative) {
                       pt = new mxPoint(this.getRoutingCenterX(terminal),
                           this.getRoutingCenterY(terminal));
                   }
               }
         
               edge.setAbsoluteTerminalPoint(pt, source);
           };
      </script>
      <!--
         Overrides methods to preview and create new edges.
         -->
      <script type="text/javascript">
         // Sets source terminal point for edge-to-edge connections.
           mxConnectionHandler.prototype.createEdgeState = function(me) {
               var edge = this.graph.createEdge();
         
               if (this.sourceConstraint != null && this.previous != null) {
                   edge.style = mxConstants.STYLE_EXIT_X + '=' + this.sourceConstraint.point.x + ';' +
                       mxConstants.STYLE_EXIT_Y + '=' + this.sourceConstraint.point.y + ';';
               } else if (this.graph.model.isEdge(me.getCell())) {
                   var scale = this.graph.view.scale;
                   var tr = this.graph.view.translate;
                   var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
                       this.graph.snap(me.getGraphY() / scale) - tr.y);
                   edge.geometry.setTerminalPoint(pt, true);
               }
         
               return this.graph.view.createState(edge);
           };
         
           mxConnectionHandler.prototype.isStopEvent = function(me) {
               return me.getState() != null || mxEvent.isRightMouseButton(me.getEvent());
           };
         
           // Updates target terminal point for edge-to-edge connections.
           mxConnectionHandlerUpdateCurrentState = mxConnectionHandler.prototype.updateCurrentState;
           mxConnectionHandler.prototype.updateCurrentState = function(me) {
               mxConnectionHandlerUpdateCurrentState.apply(this, arguments);
         
               if (this.edgeState != null) {
                   this.edgeState.cell.geometry.setTerminalPoint(null, false);
         
                   if (this.shape != null && this.currentState != null &&
                       this.currentState.view.graph.model.isEdge(this.currentState.cell)) {
                       var scale = this.graph.view.scale;
                       var tr = this.graph.view.translate;
                       var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
                           this.graph.snap(me.getGraphY() / scale) - tr.y);
                       this.edgeState.cell.geometry.setTerminalPoint(pt, false);
                   }
               }
           };
         
           // Updates the terminal and control points in the cloned preview.
           mxEdgeSegmentHandler.prototype.clonePreviewState = function(point, terminal) {
               var clone = mxEdgeHandler.prototype.clonePreviewState.apply(this, arguments);
               clone.cell = clone.cell.clone();
         
               if (this.isSource || this.isTarget) {
                   clone.cell.geometry = clone.cell.geometry.clone();
         
                   // Sets the terminal point of an edge if we're moving one of the endpoints
                   if (this.graph.getModel().isEdge(clone.cell)) {
                       clone.cell.geometry.setTerminalPoint(point, this.isSource);
                   } else {
                       clone.cell.geometry.setTerminalPoint(null, this.isSource);
                   }
               }
         
               return clone;
           };
         
           var mxEdgeHandlerConnect = mxEdgeHandler.prototype.connect;
           mxEdgeHandler.prototype.connect = function(edge, terminal, isSource, isClone, me) {
               var result = null;
               var model = this.graph.getModel();
               var parent = model.getParent(edge);
         
               model.beginUpdate();
               try {
                   result = mxEdgeHandlerConnect.apply(this, arguments);
                   var geo = model.getGeometry(result);
         
                   if (geo != null) {
                       geo = geo.clone();
                       var pt = null;
         
                       if (model.isEdge(terminal)) {
                           pt = this.abspoints[(this.isSource) ? 0 : this.abspoints.length - 1];
                           pt.x = pt.x / this.graph.view.scale - this.graph.view.translate.x;
                           pt.y = pt.y / this.graph.view.scale - this.graph.view.translate.y;
         
                           var pstate = this.graph.getView().getState(
                               this.graph.getModel().getParent(edge));
         
                           if (pstate != null) {
                               pt.x -= pstate.origin.x;
                               pt.y -= pstate.origin.y;
                           }
         
                           pt.x -= this.graph.panDx / this.graph.view.scale;
                           pt.y -= this.graph.panDy / this.graph.view.scale;
                       }
         
                       geo.setTerminalPoint(pt, isSource);
                       model.setGeometry(edge, geo);
                   }
               } finally {
                   model.endUpdate();
               }
         
               return result;
           };
      </script>
      <!--
         Adds in-place highlighting for complete cell area (no hotspot).
         -->
      <script type="text/javascript">
         mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
           mxConnectionHandler.prototype.createMarker = function() {
               var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
         
               // Uses complete area of cell for new connections (no hotspot)
               marker.intersects = function(state, evt) {
                   return true;
               };
         
               return marker;
           };
         
           mxEdgeHandlerCreateMarker = mxEdgeHandler.prototype.createMarker;
           mxEdgeHandler.prototype.createMarker = function() {
               var marker = mxEdgeHandlerCreateMarker.apply(this, arguments);
         
               // Adds in-place highlighting when reconnecting existing edges
               marker.highlight.highlight = this.graph.connectionHandler.marker.highlight.highlight;
         
               return marker;
           }
      </script>
      <!--
         Implements a perpendicular wires connection edge style
         -->
      <script type="text/javascript">
         mxEdgeStyle.WireConnector = function(state, source, target, hints, result) {
               state.cell.waypoints = state.cell.geometry.points;
               // Creates array of all way- and terminalpoints
               var pts = state.absolutePoints;
               var horizontal = true;
               var hint = null;
         
               // Gets the initial connection from the source terminal or edge
               if (source != null && state.view.graph.model.isEdge(source.cell)) {
                   horizontal = state.style['sourceConstraint'] == 'horizontal';
               }
               // If the source terminal is a Split Block, set the horizontal false
               else if (source != null && source.cell.name == 'SPLIT_f') {
                   if (state.cell.source != null) {
                       // If the port is the third child of splitBlock, only then set the horizontal as false
                       if (state.cell.source == state.cell.source.parent.getChildAt(2)) {
                           horizontal = state.style['sourceConstraint'] == 'horizontal';
                       }
                   }
               } else if (source != null) {
                   horizontal = source.style['portConstraint'] != 'vertical';
         
                   // Checks the direction of the shape and rotates
                   var direction = source.style[mxConstants.STYLE_DIRECTION];
         
                   if (direction == 'north' || direction == 'south') {
                       horizontal = !horizontal;
                   }
               }
         
               // Adds the first point
               var pt = pts[0];
         
               /* @jiteshjha splitBlock
                */
               if (state.cell.getGeometry().getTerminalPoint(true) != null) {
                   source.cell['sourcePoint'] = state.cell.getGeometry().getTerminalPoint(true);
               }
         
               if (pt == null && source != null) {
                   pt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
               } else if (pt != null) {
                   pt = pt.clone();
               }
         
               var first = pt;
               if (state.cell.getGeometry().getTerminalPoint(false) != null) {
                   target.cell['sourcePoint'] = state.cell.getGeometry().getTerminalPoint(false);
               }
         
               // Adds the waypoints
               if (hints != null && hints.length > 0) {
         
         
                   for (var i = 0; i < hints.length; i++) {
                       horizontal = !horizontal;
                       hint = state.view.transformControlPoint(state, hints[i]);
         
                       if (horizontal) {
                           if (pt.y != hint.y) {
                               pt.y = hint.y;
                               result.push(pt.clone());
                           }
                       } else if (pt.x != hint.x) {
                           pt.x = hint.x;
                           result.push(pt.clone());
                       }
                   }
               } else {
                   hint = pt;
               }
         
               // Adds the last point
               pt = pts[pts.length - 1];
               if (pt == null && target != null) {
                   pt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
         
               }
         
               if (horizontal) {
                   if (pt.y != hint.y && first.x != pt.x) {
                       result.push(new mxPoint(pt.x, hint.y));
                   }
               } else if (pt.x != hint.x && first.y != pt.y) {
                   result.push(new mxPoint(hint.x, pt.y));
               }
         
               // If the target of the edge is a splitBlock, push final coordinate as vertical.
               if (state.cell.target != null) {
                   if (state.cell.target.parent.name == "SPLIT_f") {
                       result.pop();
                       result.push(new mxPoint(hint.x, pt.y));
                   }
               }
           };
         
           mxStyleRegistry.putValue('wireEdgeStyle', mxEdgeStyle.WireConnector);
         
           // This connector needs an mxEdgeSegmentHandler
           mxGraphCreateHandler = mxGraph.prototype.createHandler;
           mxGraph.prototype.createHandler = function(state) {
               var result = null;
         
               if (state != null) {
                   if (this.model.isEdge(state.cell)) {
                       var style = this.view.getEdgeStyle(state);
         
                       if (style == mxEdgeStyle.WireConnector) {
                           return new mxEdgeSegmentHandler(state);
                       }
                   }
               }
         
               return mxGraphCreateHandler.apply(this, arguments);
           };


      </script>
   </head>
   <!-- Creating p'id for each tkblock -->
   <!-- tkchange will call GetcurVal() if any one of the slider value is updated -->
   <p hidden id="tkchange"></p>
   <p hidden id="tk1"></p>
   <p hidden id="tk2"></p>
   <p hidden id="tk3"></p>
   <p hidden id="tk4"></p>
   <p hidden id="tk5"></p>
   <p hidden id="tk6"></p>
   <p hidden id="tk7"></p>
   <p hidden id="tk8"></p>
   <p hidden id="tk9"></p>
   <p hidden id="tk10"></p>
   <!-- Page passes the container for the graph to the program -->
   <body onload="main(document.getElementById('graphContainer'),
      document.getElementById('outlineContainer'),
      document.getElementById('toolbarContainer'),
      document.getElementById('sidebarContainer'),
      document.getElementById('statusContainer'));" style="margin:0px;">
      <!-- Creates a container for the splash screen -->
      <div id="splash" style="position:absolute;top:0px;left:0px;width:100%;height:100%;background:white;z-index:1;">
         <center id="splash" style="padding-top:230px;">
            <img src="images/loading.gif"/>
         </center>
      </div>
      <!-- Creates a container for the sidebar -->
      <div id="toolbarContainer" style="position:absolute;white-space:nowrap;overflow:hidden;top:0px;left:0px;max-height:24px;height:36px;right:0px;padding:6px;background-image:url('images/toolbar_bg.gif');"></div>
      <!-- Creates a container for the toolbox -->
      <div class="ui-accordion ui-widget ui-helper-reset" id="sidebarContainer" style="position:absolute;overflow:scroll;top:36px;left:0px;bottom:36px;max-width:266px;width:270px;padding-top:10px;padding-left:4px;"></div>
      <!-- Creates a container for the graph -->
      <div id="graphContainer" style="position:absolute;overflow:hidden;top:36px;left:270px;bottom:36px;right:0px;background-image:url('images/grid.gif');cursor:default;"></div>
      <!-- Creates a container for the outline -->
      <div id="outlineContainer" style="position:absolute;overflow:hidden;top:36px;right:0px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;"></div>
      <!-- Creates a container for the sidebar -->
      <div id="statusContainer" style="text-align:right;position:absolute;overflow:hidden;bottom:0px;left:0px;max-height:24px;height:36px;right:0px;color:white;padding:6px;background-image:url('images/toolbar_bg.gif');">
         <div style="font-size:10pt;float:left;">
            <a href="http://fossee.in/" target="_tab">
            FOSSEE
            </a>
         </div>
      </div>
      <!-- Secret -->
      <p class="accordion-expand-holder" style="display:none">
         <a class="accordion-expand-all" id="toggleBlocks">
         Expand All
         </a>
      </p>
   </body>
   <!-- It's good if this part happens after the entire page has loaded-->
   <script type="text/javascript">
      // Preload all images
        var directory = ["/blocks/", "/images/", "/palettes/"];
        for (folder in directory) {
            $.ajax({
                type: "POST",
      
                // Invoke filenames.php
                url: "filenames.php",
      
                // Receive the resultant filenames from the php script in JSON format
                dataType: "json",
      
                // Add url for the required folder
                data: {
                    url: directory[folder]
                },
                success: function(data) {
                    function preload(sources) {
      
                        /*
                         * @Parameter: sources will have the required filenames in the mentioned folder
                         * For each image url, make a new image to enable preloading
                         */
                        for (i in sources) {
                            var image = new Image();
                            image.src = sources[i];
                        }
                    }
                    preload(data);
                }
            });
        }
      
        //Find out more here: http://stackoverflow.com/questions/12843418/jquery-ui-accordion-expand-collapse-all
        $(window).load(function() {
            var headers = $('#sidebarContainer .accordion-header');
            var contentAreas = $('#sidebarContainer .ui-accordion-content ').hide();
            var expandLink = $('.accordion-expand-all');
      
            // add the accordion functionality
            headers.click(function() {
                var panel = $(this).next();
                var isOpen = panel.is(':visible');
      
                // open or close as necessary
                panel[isOpen ? 'slideUp' : 'slideDown']()
                    // trigger the correct custom event
                    .trigger(isOpen ? 'hide' : 'show');
      
                // stop the link from causing a pagescroll
                return false;
            });
      
            // hook up the expand/collapse all
            expandLink.click(function() {
                var isAllOpen = $(this).data('isAllOpen');
      
                contentAreas[isAllOpen ? 'hide' : 'show']()
                    .trigger(isAllOpen ? 'hide' : 'show');
            });
      
            // when panels open or close, check to see if they're all open
            contentAreas.on({
                // whenever we open a panel, check to see if they're all open
                // if all open, swap the button to collapser
                show: function() {
                    var isAllOpen = !contentAreas.is(':hidden');
                    if (isAllOpen) {
                        expandLink.text('Collapse All')
                            .data('isAllOpen', true);
                    }
                },
                // whenever we close a panel, check to see if they're all open
                // if not all open, swap the button to expander
                hide: function() {
                    var isAllOpen = !contentAreas.is(':hidden');
                    if (!isAllOpen) {
                        expandLink.text('Expand All')
                            .data('isAllOpen', false);
                    }
                }
            });
        });
   </script>
</html>


